1. 将图拆分为树
2. 将树的节点染上三种颜色
3. 将树的边染上颜色，注意冲突，最多使用$2\Delta-1$种颜色。

- 图的表达：
  - 两个数组，`row[i]`和`col[i]`，分别表示第`i`条边对应的两个节点号。
  - 应该有`i < n_edge`。
  - 总有`row[i] < col[i]`。
  - 对应到邻接矩阵中，是上三角。
  - 按邻接矩阵行优先存储。
  - 将图分成一些有向的根树组成的森林。
  - 生成的树按下一条存储。

- 树的表达：
  - 四个数组，`row[i]`和`col[i]`分别表示第`i`条边对应的两个节点号，`tree[j]`表示第`j`棵树的起始边序号，`forest[k]`表示第`k`个森林的起始树序号。
  - 应该有`i < n_edge`，`j < Delta`。
  - 按森林存储，每个森林按树存储，每棵树按邻接矩阵行优先存储。
  - 树是有向树，方向从较高的节点号指向较低的节点号。
  - 一棵树的根节点对应相应范围中`col[i]`最大的那个。
  - 将树的节点染3种颜色。
  - 染色的树按下一条存储。

- 染色的树的表达：
  - 四个数组，`row[i]`和`col[i]`分别表示第`i`条边对应的两个节点号，`color[j][k]`表示第`j`个森林第`k`种颜色的边序号，`used[l]`表示第`l`号节点使用过的颜色，用$2\Delta-1$位的数字存储。
  - 应该有`i < n_edge`，`j < Delta`，`k < 3`，`l < n_vertex`。
  - 对某个森林中的某个颜色的边并行，将这些边染成不同且不与两端节点使用过的颜色重复的颜色。
  - 将染好色的边排列输出。

- 染色的图的表达
  - 四个数组，`row[i]`和`col[i]`分别表示第`i`条边对应的两个节点号，`color[j]`表示第`j`种颜色的起始边序号。
  - 应该有`i<n_edge`，`j<2*Delta-1`。
  - 按颜色存储。